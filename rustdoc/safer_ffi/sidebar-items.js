initSidebarItems({"attr":[["cfg_headers",""],["derive_ReprC","Safely implement `ReprC` for a `#[repr(C)]` struct when all its fields are `ReprC`."],["ffi_export","Export a function to be callable by C."]],"macro":[["CType","Safely implement [`CType`][`trait@crate::layout::CType`] for a `#[repr(C)]` struct when all its fields are `CType`."],["NULL",""],["ReprC","Safely implement [`ReprC`][`trait@crate::layout::ReprC`] for a `#[repr(C)]` struct when all its fields are `ReprC`."],["c","Creates a compile-time checked `char_p::Ref``<'static>` out of a string literal."],["c_vec",""]],"mod":[["boxed","`#[repr(C)]` [`Box`][`rust::Box`]ed types."],["char_p","`char *`-compatible strings (slim pointers), for easier use from within C. They thus do not support inner nulls, nor string appending."],["closure","Closures with a `#[repr(C)]` layout (inlined vtable), up to 9 function arguments."],["headers","C headers generation."],["layout","Trait abstractions describing the semantics of “being `#[repr(C)]`”"],["prelude",""],["ptr","Wrappers around `NonNull` to better express the semantics of such pointer."],["slice","Logic common to all fat pointers."],["string","`Rust` string types with a defined `#[repr(C)]` layout, albeit not `char *` compatible (fat pointers)."],["tuple","Tuple types with a guaranteed `#[repr(C)]` layout."],["vec",""]],"struct":[["String","Same as [`String`][`rust::String`], but with guaranteed `#[repr(C)]` layout"],["Vec","Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]]});